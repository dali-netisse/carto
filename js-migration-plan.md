# JavaScript Migration Plan

## Project Structure (Node.js)

*   `src/`: Main JavaScript source code.
    *   `main.js` (or `index.js`): Script entry point.
    *   `svgParser.js`: Logic for parsing SVG and extracting elements.
    *   `geometry.js`: Transformation functions, path parsing, point manipulation.
    *   `objectHandlers.js`: Logic for different object types (POIs, desks, etc.).
    *   `config.js` (or `data/`): For ported hardcoded data like calage and ID fixes.
*   `tests/`: Unit and integration tests.
    *   `test-data/`: Sample SVG snippets or simplified SVGs for unit tests.
*   `output-js/`: Directory for JSON output generated by the JS script (for comparison).
*   `README.md`: Project specific readme.
*   `package.json`: Node.js project manifest.

## Core Node.js Modules & External Libraries

*   **XML/SVG Parsing:**
    *   Research candidates: `xmldom` (with `xpath`), `svg-parser` (from `npm`), `xml2js`. Need one that supports XPath queries or provides a good DOM structure.
    *   Decision criteria: Ease of use, XPath support, SVG compatibility, active maintenance.
*   **JSON Generation:**
    *   Native `JSON.stringify()` with appropriate formatting (pretty print, sorted keys if possible to match Perl's `canonical`).
*   **SVG Path Parsing:**
    *   Research candidates: `svgpath`, `parse-svg-path`, `abs-svg-path`. Or, direct porting of Perl's path parsing logic.
    *   Decision criteria: Accuracy, ability to handle all SVG path commands, ease of applying transformations.
*   **Unicode Normalization:**
    *   `String.prototype.normalize('NFD')` in JavaScript for equivalent of Perl's `NFD`.
*   **File System:** `fs` module (Node.js built-in).
*   **Argument Parsing:** `yargs` or `commander`.
*   **Testing Framework:** `jest` or `mocha`.

## Handling Hardcoded Data

*   `%calage` (Perl hash): Convert to a JSON file (`calage.json`) or a JavaScript object module (`calageData.js`).
*   `%id_fixes` (Perl hash): Similar to `%calage`, convert to JSON or a JS module.
*   Other specific transformations/fallbacks: Embed as conditional logic or data structures in the JS code.

## Key Migration Steps (High-Level - to be detailed later)

*   SVG loading and initial parsing.
*   Calibration ("Calage") rectangle processing and global transform setup.
*   Transformation logic (points, rects, lines, polygons, paths).
*   Element processing (background, decor, itineraries, POIs, desks, furniture).
*   ID and label parsing for classification.
*   JSON output generation.
*   Testing and validation against Perl output.

## Testing Strategy

*   Unit tests for individual functions (transformations, path segment parsing, ID parsing, etc.).
*   Integration tests using the main `Brune R+7.svg` file and comparing the full JSON output.
*   Use `output/BRU-7.json` as the "golden" reference.
*   Output from JS script will be saved to `js-output/BRU-7.json` for direct comparison.

## Potential Challenges

*   Accurately replicating Perl's SVG path parsing and transformation logic, especially for complex paths and transforms.
*   Ensuring identical floating-point precision and rounding if it impacts coordinates.
*   Matching the exact behavior of `XML::LibXML` and its XPath queries.
*   Thoroughly porting all edge cases and implicit behaviors from the Perl script.
*   The sheer volume of specific regexes and hardcoded fixes.
